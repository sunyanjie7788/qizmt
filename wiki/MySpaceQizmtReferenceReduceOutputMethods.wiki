#summary Qizmt Reference ReduceOutput Methods
#labels Qizmt,Reference,Binary,API,ReduceOutput,Methods

<wiki:comment>Image:</wiki:comment><img src="http://qizmt.googlecode.com/svn/wiki/images/Qizmt_logo_small.png" alt="Qizmt logo (small)" />

Back to <wiki:comment>Link:</wiki:comment>[Main Wiki Main] / [MySpaceQizmtReference MySpace Qizmt Reference]

<wiki:toc max_depth="2" />

=Methods of `ReduceOutput` (Equivalent to `RandomAccessOutput`)=


==`Add`==
{{{public void Add(ByteSlice entry)}}}

Adds entryâ€™s buffer to output file with a new line

====Example 1==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    string sKey = UnpadKey(key).ToString();
    string sValue = "";

    for (int i = 0; i < values.Length; i++)
        sValue += "," + values[i].Value.ToString();

    output.Add(ByteSlice.Prepare("key=" + sKey));
    output.Add(ByteSlice.Prepare("values=" + sValue));
} 
}}}


====Example 2====
This example demonstrates what happens when changing the buffer after the ByteSlice has already been created, but before it is added to the 

RandomAccesOutput.  You will see the change in the RandomAccesOutput.

{{{
//Map code
public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    string[] parts = sLine.Split(',');

    output.Add(ByteSlice.PreparePaddedStringAscii(parts[0], Qizmt_KeyLength), ByteSlice.Prepare(parts[1]));

}

//Reducer code
byte[] buffer = new byte[Qizmt_KeyLength + 4];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    string s = "key=" + UnpadKey(key).ToString();

    Entry.AsciiToBytes(s, buffer, 0);

    ByteSlice b = ByteSlice.Prepare(buffer);

    //Change one byte in the buffer.  This change will be carried to the output.
    buffer[0] = 0x0;

    output.Add(b);
}
/*
Sample Input:

123,apple
234,lemon
444,berry

Sample Output:

key=123            
key=234             
key=444 
*/
}}}


====Example 3====
This example demonstrates what happens when changing the buffer after the ByteSlice has already been created and after it has been added to the 

RandomAccessOutput.  You will NOT see the change in the RandomAccessOutput.

{{{
//Map code
public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    string[] parts = sLine.Split(',');

    output.Add(ByteSlice.PreparePaddedStringAscii(parts[0], Qizmt_KeyLength), ByteSlice.Prepare(parts[1]));

}

//Reducer code
byte[] buffer = new byte[Qizmt_KeyLength + 4];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    string s = "key=" + UnpadKey(key).ToString();

    Entry.AsciiToBytes(s, buffer, 0);

    ByteSlice b = ByteSlice.Prepare(buffer);

    output.Add(b);

    //Change one byte in the buffer.  This change will NOT be carried to the output.
    buffer[0] = 0x0;

}
/*
Sample Input:

123,apple
234,lemon
444,berry

Sample Output:

key=123            
key=234             
key=444 
*/
}}}
----



{{{public void Add(mstring s)}}}

Writes the mstring to the output file.

====Example==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    recordset rKey = recordset.Prepare(key);

    int i1 = rKey.GetInt32();
    int i2 = rKey.GetInt32();

    mstring ms = mstring.Prepare();

    for (int i = 0; i < values.Length; i++)
    {
        recordset rValue = recordset.Prepare(values[i].Value);

        Int64 i3 = rValue.GetInt64();
        mstring s = rValue.GetString();
        int i4 = rValue.GetInt32();
        mstring delimiter = mstring.Prepare(",");

        ms.Consume(ref s);
        ms.Consume(ref delimiter);
    }

    output.Add(ms);
} 
}}}
----



==`WriteLine`==
{{{public void WriteLine(mstring s)}}}

Writes the mstring to the output file.

====Example==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    recordset rKey = recordset.Prepare(key);

    int i1 = rKey.GetInt32();
    int i2 = rKey.GetInt32();

    mstring ms = mstring.Prepare();

    for (int i = 0; i < values.Length; i++)
    {
        recordset rValue = recordset.Prepare(values[i].Value);

        Int64 i3 = rValue.GetInt64();
        mstring s = rValue.GetString();
        int i4 = rValue.GetInt32();
        mstring delimiter = mstring.Prepare(",");

        ms.Consume(ref s);
        ms.Consume(ref delimiter);
    }

    output.WriteLine(ms);
} 
}}}
----



==`Cache`==
{{{public void Cache(ByteSlice key, ByteSlice value)}}}

Writes key and value to explicit cache.
====Remarks====
Once a key-value pair has been added to explicit cache, the next time mapReducer runs, the values will be passed back in.  Keys cannot be changed. 

 Explicit cache overrides the automatic cache.  It speeds up subsequent runs.

====Example==== 
Specify cache configurations:

{{{
<Delta>
    <Name>MyMapReduce_Cache</Name>
    <DFSInput>dfs://data_input_*.txt</DFSInput>
</Delta>
<IOSettings>
    <JobType>mapreduce</JobType>
    <KeyLength>100</KeyLength>
    <DFSInput>dfs://NOTHING*NOTHING</DFSInput>
    <DFSOutput>dfs://MyMapReduce_Output.txt</DFSOutput>
</IOSettings>
}}}


{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    string sKey = UnpadKey(key).ToString();
    string sValue = "";

    for (int i = 0; i < values.Length; i++)
    {
        sValue += "," + values[i].Value.ToString();
        output.Cache(key, values[i].Value);
    }

    output.Add(ByteSlice.Prepare("key=" + sKey), true);
    output.Add(ByteSlice.Prepare("values=" + sValue), true);
} 
}}}
----



{{{public void Cache(string key, string value)}}}

Writes key string and value string to explicit cache.
====Remarks====
Once a key-value pair has been added to explicit cache, the next time mapReducer runs, the values will be passed back in.  Keys cannot be changed. 

 Explicit cache overrides the automatic cache.  It speeds up subsequent runs.

====Example==== 
Specify cache configurations:

{{{
<Delta>
    <Name>MyMapReduce_Cache</Name>
    <DFSInput>dfs://data_input_*.txt</DFSInput>
</Delta>
<IOSettings>
    <JobType>mapreduce</JobType>
    <KeyLength>100</KeyLength>
    <DFSInput>dfs://NOTHING*NOTHING</DFSInput>
    <DFSOutput>dfs://MyMapReduce_Output.txt</DFSOutput>
</IOSettings>
}}}


{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    mstring sKey = mstring.Prepare(UnpadKey(key));
    mstring sLine = mstring.Prepare();

    for (int i = 0; i < values.Length; i++)
    {
        mstring sValue = mstring.Prepare(values[i].Value);
        sLine.AppendM(sValue);
        sLine.AppendM(',');

        output.Cache("1", "10");
    }

    output.Add(sKey);
    output.Add(sLine);
}
}}}
----



{{{public void Cache(recordset key, recordset value)}}}

Writes key recordset and value recordset to explicit cache.
====Remarks====
Once a key-value pair has been added to explicit cache, the next time mapReducer runs, the values will be passed back in.  Keys cannot be changed. 

 Explicit cache overrides the automatic cache.  It speeds up subsequent runs.

====Example==== 
Specify cache configurations:

{{{
<Delta>
    <Name>MyMapReduce_Cache</Name>
    <DFSInput>dfs://data_input_*.txt</DFSInput>
</Delta>
<IOSettings>
    <JobType>mapreduce</JobType>
    <KeyLength>100</KeyLength>
    <DFSInput>dfs://NOTHING*NOTHING</DFSInput>
    <DFSOutput>dfs://MyMapReduce_Output.txt</DFSOutput>
</IOSettings>
}}}


{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    recordset rKey = recordset.Prepare(UnpadKey(key));

    for (int i = 0; i < values.Length; i++)
    {
        recordset rValue = recordset.Prepare(values[i].Value);

        output.Cache(rKey, recordset.Prepare());
    }
} 
}}}
----



{{{public void Cache(mstring key, mstring value)}}}

Writes key mstring and value mstring to explicit cache.
====Remarks====
Once a key-value pair has been added to explicit cache, the next time mapReducer runs, the values will be passed back in.  Keys cannot be changed. 

 Explicit cache overrides the automatic cache.  It speeds up subsequent runs.

====Example==== 
Specify cache configurations:

{{{
<Delta>
    <Name>MyMapReduce_Cache</Name>
    <DFSInput>dfs://data_input_*.txt</DFSInput>
</Delta>
<IOSettings>
    <JobType>mapreduce</JobType>
    <KeyLength>100</KeyLength>
    <DFSInput>dfs://NOTHING*NOTHING</DFSInput>
    <DFSOutput>dfs://MyMapReduce_Output.txt</DFSOutput>
</IOSettings>
}}}


{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    mstring sKey = mstring.Prepare(UnpadKey(key));
    mstring sLine = mstring.Prepare();

    for (int i = 0; i < values.Length; i++)
    {
        mstring sValue = mstring.Prepare(values[i].Value);
        sLine.AppendM(sValue);
        sLine.AppendM(',');

        output.Cache(sKey, mstring.Prepare());
    }

    output.Add(sKey);
    output.Add(sLine);
} 
}}}
----



{{{public void Cache(mstring key, recordset value)}}}

Writes key mstring and value recordset to explicit cache.
====Remarks====
Once a key-value pair has been added to explicit cache, the next time mapReducer runs, the values will be passed back in.  Keys cannot be changed. 

 Explicit cache overrides the automatic cache.  It speeds up subsequent runs.

====Example==== 
Specify cache configurations:

{{{
<Delta>
    <Name>MyMapReduce_Cache</Name>
    <DFSInput>dfs://data_input_*.txt</DFSInput>
</Delta>
<IOSettings>
    <JobType>mapreduce</JobType>
    <KeyLength>100</KeyLength>
    <DFSInput>dfs://NOTHING*NOTHING</DFSInput>
    <DFSOutput>dfs://MyMapReduce_Output.txt</DFSOutput>
</IOSettings>
}}}


{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    mstring sKey = mstring.Prepare(UnpadKey(key));

    for (int i = 0; i < values.Length; i++)
    {
        recordset rs = recordset.Prepare(values[i].Value);

        output.Cache(sKey, rs);
    }
} 
}}}