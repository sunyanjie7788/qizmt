#summary Qizmt Reference Entry Static Methods
#labels Qizmt,Reference,Binary,API,Entry,Static,Methods

<wiki:comment>Image:</wiki:comment><img src="http://qizmt.googlecode.com/svn/wiki/images/Qizmt_logo_small.png" alt="Qizmt logo (small)" />

Back to <wiki:comment>Link:</wiki:comment>[Main Wiki Main] / [MySpaceQizmtReference MySpace Qizmt Reference]

<wiki:toc max_depth="2" />

=Static Methods of Entry=

 * [MySpaceQizmtReferenceEntryToBytes ToBytes]
 * [MySpaceQizmtReferenceEntryToBytesAppend ToBytesAppend]
 * [MySpaceQizmtReferenceEntryToUInt32 ToUInt32]
 * [MySpaceQizmtReferenceEntryToInt32 ToInt32]
 * [MySpaceQizmtReferenceEntryUInt32ToBytes UInt32ToBytes]
 * [MySpaceQizmtReferenceEntryUInt32ToBytesAppend UInt32ToBytesAppend]
 * [MySpaceQizmtReferenceEntryUInt16ToBytes UInt16ToBytes]
 * [MySpaceQizmtReferenceEntryInt16ToBytes Int16ToBytes]
 * [MySpaceQizmtReferenceEntryToUInt16 ToUInt16]
 * [MySpaceQizmtReferenceEntryToInt16 ToInt16]
 * [MySpaceQizmtReferenceEntryLongToBytes LongToBytes]
 * [MySpaceQizmtReferenceEntryToBytesAppend64 ToBytesAppend64]
 * [MySpaceQizmtReferenceEntryBytesToInt BytesToInt]
 * [MySpaceQizmtReferenceEntryBytesToUInt32 BytesToUInt32]
 * [MySpaceQizmtReferenceEntryBytesToUInt16 BytesToUInt16]
 * [MySpaceQizmtReferenceEntryBytesToLong BytesToLong]
 * [MySpaceQizmtReferenceEntryBytesToInt16 BytesToInt16]
 * [MySpaceQizmtReferenceEntryAsciiToBytesAppend AsciiToBytesAppend]
 * [MySpaceQizmtReferenceEntryAsciiToBytes AsciiToBytes]
 * [MySpaceQizmtReferenceEntryBytesToAscii BytesToAscii]
 * [MySpaceQizmtReferenceEntryBytesToAsciiAppend BytesToAsciiAppend]



==`ToBytes`==
{{{public static byte[] ToBytes(Int32 x)}}}

Converts int x to bytes in big endian byte ordering.
====Remarks====
A new `byte[]` is allocated each time this method is called.  Consider a more efficient overload of this method in which a `byte[]` is passed in 

as a parameter, or consider the `ToBytesAppend` method.

====Example==== 
{{{
//Map code
public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();	
    byte[] buffer = Entry.ToBytes(Convert.ToInt32(sLine));
    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
}


//Reducer code
byte[] buffer = new byte[4];
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);
    int num = Entry.BytesToInt(buffer);
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



{{{public static void ToBytes(Int32 x, byte[] resultbuf, int bufoffset)}}}

Converts int x to bytes in big endian byte ordering with offset.
====Remarks====
Please see example 2 when sorting on a mixture of negative and positive integers.  

====Example 1==== 
This example sorts positive integers.

{{{
byte[] myBuffer = new byte[4];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    Entry.ToBytes(Convert.ToInt32(sLine), myBuffer, 0);
    output.Add(ByteSlice.Prepare(myBuffer), ByteSlice.Prepare());
} 
}}}

====Example 2====
This example sorts a mixture of negative and positive integers.  

{{{
//Map code
byte[] buffer = new byte[4];
public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();

    UInt32 i = Entry.ToUInt32(Convert.ToInt32(sLine));
    Entry.UInt32ToBytes(i, buffer, 0);

    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
}

//Reducer code

byte[] buffer = new byte[4];
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);

    int num = Entry.ToInt32(Entry.BytesToUInt32(buffer));

    output.Add(ByteSlice.Prepare(num.ToString()));
}
}}}
----



==`ToBytesAppend`==
{{{public static void ToBytesAppend(Int32 x, List<byte> list)}}}

Converts int x to bytes in big endian byte ordering and appends to list.

====Example==== 
{{{
List<byte> myBuffer = new List<byte>();

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    myBuffer.Clear();
    Entry.ToBytesAppend(Convert.ToInt32(sLine), myBuffer);
    output.Add(ByteSlice.Prepare(myBuffer), ByteSlice.Prepare());
} 
}}}
----



==`ToUInt32`==
{{{public static UInt32 ToUInt32(Int32 x)}}}

Converts int x to UInt32.

====Example==== 
This example sorts a mixture of negative and positive integers.

{{{
//Map code
byte[] buffer = new byte[4];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();

    UInt32 i = Entry.ToUInt32(Convert.ToInt32(sLine));
    Entry.UInt32ToBytes(i, buffer, 0);

    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
}

//Reducer code
byte[] buffer = new byte[4];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);

    int num = Entry.ToInt32(Entry.BytesToUInt32(buffer));

    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`ToInt32`==
{{{public static Int32 ToInt32(UInt32 x)}}}

Converts UInt32 to int.

====Example====
This example sorts a mixture of negative and positive integers.
 
{{{
//Map code
byte[] buffer = new byte[4];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();

    UInt32 i = Entry.ToUInt32(Convert.ToInt32(sLine));
    Entry.UInt32ToBytes(i, buffer, 0);

    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
}

//Reducer code
byte[] buffer = new byte[4];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);

    int num = Entry.ToInt32(Entry.BytesToUInt32(buffer));

    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`UInt32ToBytes`==
{{{public static byte[] UInt32ToBytes(UInt32 x)}}}

Converts UInt32 x to bytes in big endian byte ordering.   A new byte array is allocated each time this method is called.  Consider a more 

efficient overload of this method or `UInt32ToBytesAppend`.

====Example==== 
This example sorts a mixture of negative and positive integers.  

{{{
//Map code
public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();

    UInt32 i = Entry.ToUInt32(Convert.ToInt32(sLine));
    byte[] buffer = Entry.UInt32ToBytes(i);

    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
}

//Reducer code
public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();

    UInt32 i = Entry.ToUInt32(Convert.ToInt32(sLine));
    byte[] buffer = Entry.UInt32ToBytes(i);

    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
} 
}}}
----



{{{public static void UInt32ToBytes(UInt32 x, byte[] buffer, int offset)}}}

Converts UInt32 x to bytes in big endian byte ordering.

====Example==== 
This example sorts a mixture of negative and positive integers. 

{{{
//Map code
byte[] buffer = new byte[4];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();

    UInt32 i = Entry.ToUInt32(Convert.ToInt32(sLine));
    Entry.UInt32ToBytes(i, buffer, 0);

    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
}

//Reducer code
byte[] buffer = new byte[4];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);

    int num = Entry.ToInt32(Entry.BytesToUInt32(buffer));

    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`UInt32ToBytesAppend`==
{{{public static void UInt32ToBytesAppend(UInt32 x, List<byte> buffer)}}}

Converts UInt32 x to bytes in big endian byte ordering and appends to buffer.

====Example==== 
This example sorts a mixture of negative and positive integers. 

{{{
//Map code
List<byte> buffer = new List<byte>();

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();

    UInt32 i = Entry.ToUInt32(Convert.ToInt32(sLine));

    buffer.Clear();
    Entry.UInt32ToBytesAppend(i, buffer);

    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
}

//Reducer code
byte[] buffer = new byte[4];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);

    int num = Entry.ToInt32(Entry.BytesToUInt32(buffer));

    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`UInt16ToBytes`==
{{{public static byte[] UInt16ToBytes(UInt16 x)}}}

Converts UInt16  x to bytes in big endian byte ordering.
====Remarks====
A byte array is allocated each time this method is called.  Consider a more efficient overload of this method.

====Example==== 
{{{
public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    UInt16 i = Convert.ToUInt16(sLine);
    byte[] buffer = Entry.UInt16ToBytes(i);
    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare(""));
} 
}}}
----



{{{public static void UInt16ToBytes(UInt16 x, byte[] resultbuf, int bufoffset)}}}

Converts UInt16  x to bytes in big endian byte ordering.

====Example==== 
{{{
byte[] buffer = new byte[2];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    UInt16 i = Convert.ToUInt16(sLine);
    Entry.UInt16ToBytes(i, buffer, 0);
    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare(""));
} 
}}}
----



==`Int16ToBytes`==
{{{public static byte[] Int16ToBytes(Int16 x)}}}

Converts Int16 x to bytes in big endian byte ordering.
====Remarks====
A new `byte[]` is allocated each time this method is called.  Consider a more efficient overload of this method in which a `byte[]` is passed in 

as a parameter.

====Example==== 
{{{
public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    byte[] myBuffer = Entry.Int16ToBytes(Convert.ToInt16(sLine));
    output.Add(ByteSlice.Prepare(myBuffer), ByteSlice.Prepare());
} 
}}}
----



{{{public static void Int16ToBytes(Int16 x, byte[] resultBuffer, int offset)}}}

Converts Int16 x to bytes in big endian byte ordering with offset.

====Example==== 
{{{
byte[] myBuffer = new byte[2];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    Entry.Int16ToBytes(Convert.ToInt16(sLine), myBuffer, 0);
    output.Add(ByteSlice.Prepare(myBuffer), ByteSlice.Prepare());
} 
}}}
----



==`ToUInt16`==
{{{public static UInt16 ToUInt16(Int16 x)}}}

Converts Int16 x to UInt16.

====Example==== 
This example sorts a mixture of positive and negative integers of type Int16.

{{{
//Map code
byte[] buffer = new byte[2];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    UInt16 i = Entry.ToUInt16(Convert.ToInt16(sLine));
    Entry.UInt16ToBytes(i, buffer, 0);
    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare(""));
}

//Reducer code
byte[] buffer = new byte[2];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);
    Int16 num = Entry.ToInt16(Entry.BytesToUInt16(buffer));
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`ToInt16`==
{{{public static Int16 ToInt16(UInt16 x)}}}

Converts UInt16 x to Int16.

====Example==== 
This example sorts a mixture of positive and negative integers of type Int16.

{{{
//Map code
byte[] buffer = new byte[2];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    UInt16 i = Entry.ToUInt16(Convert.ToInt16(sLine));
    Entry.UInt16ToBytes(i, buffer, 0);
    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare(""));
}

//Reducer code
byte[] buffer = new byte[2];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);
    Int16 num = Entry.ToInt16(Entry.BytesToUInt16(buffer));
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`LongToBytes`==
{{{public static void LongToBytes(long x, byte[] resultBuffer, int offset)}}}

Converts long x to bytes in big endian byte ordering at offset.

====Example==== 
{{{
byte[] myBuffer = new byte[8];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    Entry.LongToBytes(Convert.ToInt64(sLine), myBuffer, 0);
    output.Add(ByteSlice.Prepare(myBuffer), ByteSlice.Prepare());
} 
}}}
----



==`ToBytesAppend64`==
{{{public static void ToBytesAppend64(Int64 x, List<byte> list)}}}

Converts int x to bytes in big endian byte ordering and appends to list.

====Example==== 
{{{
List<byte> myBuffer = new List<byte>();

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    myBuffer.Clear();
    Entry.ToBytesAppend64(Convert.ToInt64(sLine), myBuffer);
    output.Add(ByteSlice.Prepare(myBuffer), ByteSlice.Prepare());
} 
}}}
----



==`BytesToInt`==
{{{public static Int32 BytesToInt(IList<byte> x)}}}

Converts bytes, which are in big endian byte ordering, to int.

====Example==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    int num = Entry.BytesToInt(key.ToBytes());
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



{{{public static Int32 BytesToInt(IList<byte> x, int offset)}}}

Converts bytes, which is in big endian byte ordering, starting at offset to int.

====Example==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    int num = Entry.BytesToInt(key.ToBytes(), 0);
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`BytesToUInt32`==
{{{public static UInt32 BytesToUInt32(IList<byte> x)}}}

Converts bytes, which are in big endian byte ordering, to UInt32.

====Example==== 
This example sorts a mixture of negative and positive integers.  

{{{
//Map code
byte[] buffer = new byte[4];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();

    UInt32 i = Entry.ToUInt32(Convert.ToInt32(sLine));
    Entry.UInt32ToBytes(i, buffer, 0);

    output.Add(ByteSlice.Prepare(buffer), ByteSlice.Prepare());
}

//Reducer code
byte[] buffer = new byte[4];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);

    int num = Entry.ToInt32(Entry.BytesToUInt32(buffer));

    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`BytesToUInt16`==
{{{public static UInt16 BytesToUInt16(IList<byte> x)}}}

Converts the bytes, which are in big endian byte ordering, to UInt16.

====Example==== 
{{{
byte[] buffer = new byte[2];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);

    UInt16 num = Entry.BytesToUInt16(buffer);

    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



{{{public static UInt16 BytesToUInt16(IList<byte> x, int offset)}}}

Converts the bytes, which are in big endian byte ordering, to UInt16, starting at offset.

====Example==== 
{{{
byte[] buffer = new byte[2];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    key.CopyTo(buffer);

    UInt16 num = Entry.BytesToUInt16(buffer, 0);

    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`BytesToLong`==
{{{public static Int64 BytesToLong(IList<byte> x)}}}

Converts bytes, which are in big endian byte ordering, to long.

====Example==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    Int64 num = Entry.BytesToLong(key.ToBytes());
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



{{{public static long BytesToLong(IList<byte> x, int offset)}}}

Converts bytes, which are in big endian byte ordering, starting at offset to long.

====Example==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    Int64 num = Entry.BytesToLong(key.ToBytes(), 0);
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`BytesToInt16`==
{{{public static Int16 BytesToInt16(IList<byte> x)}}}

Converts bytes, which are in big endian byte ordering, to int.

====Example==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    Int16 num = Entry.BytesToInt16(key.ToBytes());
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



{{{public static Int16 BytesToInt16(IList<byte> x, int offset)}}}

Converts bytes, which are in big endian byte ordering, starting at offset to int.

====Example==== 
{{{
public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    Int16 num = Entry.BytesToInt16(key.ToBytes(), 0);
    output.Add(ByteSlice.Prepare(num.ToString()));
} 
}}}
----



==`AsciiToBytesAppend`==
{{{public static void AsciiToBytesAppend(StringBuilder x, List<byte> list)}}}

Converts string to bytes using ASCII encoding and appends to list.

====Example==== 
{{{
StringBuilder sb = new StringBuilder();
List<byte> myBuffer = new List<byte>();

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    string[] parts = sLine.Split(',');

    myBuffer.Clear();
    sb.Length = 0;
    sb.Append(parts[1]);

    for (int i = 0; i < sb.Length; i++)
    {
        //Code for manipulating the StringBuilder...                  
    }

    Entry.AsciiToBytesAppend(sb, myBuffer);
    output.Add(ByteSlice.PreparePaddedStringAscii(parts[0], Qizmt_KeyLength), ByteSlice.Prepare(myBuffer));
} 
}}}
----



{{{public static void AsciiToBytesAppend(string x, List<byte> list)}}}

Converts string to bytes using ASCII encoding and appends to list.

====Example==== 
{{{
List<byte> myBuffer = new List<byte>();

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    string[] parts = sLine.Split(',');
    myBuffer.Clear();
    string value = parts[1];

    for (int i = 0; i < value.Length; i++)
    {
        //Code for manipulating the string...                  
    }

    Entry.AsciiToBytesAppend(value, myBuffer);
    output.Add(ByteSlice.PreparePaddedStringAscii(parts[0], Qizmt_KeyLength), ByteSlice.Prepare(myBuffer));
} 
}}}
----



==`AsciiToBytes`==
{{{public static void AsciiToBytes(string x, byte[] buffer, int offset)}}}

Converts string to bytes using ASCII encoding and appends to buffer with offset.

====Example==== 
{{{
byte[] myBuffer = new byte[10];

public virtual void Map(ByteSlice line, MapOutput output)
{
    string sLine = line.ToString();
    string[] parts = sLine.Split(',');
    string value = parts[1];
    for (int i = 0; i < value.Length; i++)
    {
        //Some code for manipulating the string...                  
    }

    Entry.AsciiToBytes(value, myBuffer, 0);
    output.Add(ByteSlice.Prepare(parts[0].PadRight(16, '\0')), ByteSlice.Prepare(myBuffer));
} 
}}}
----



==`BytesToAscii`==
{{{public static string BytesToAscii(IList<byte> x)}}}

Converts bytes to string using ASCII encoding.
====Remarks====
A new string is allocated each time this method is called.  Consider the more efficient method `BytesToAsciiAppend`.

====Example==== 
{{{
byte[] myBuffer = new byte[10];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    string sKey = UnpadKey(key).ToString();
    string sValue = "";

    for (int i = 0; i < values.Length; i++)
    {
        values[i].Value.CopyTo(myBuffer);
        sValue = Entry.BytesToAscii(myBuffer);

        //Code for manipulating the string...

    }

    output.Add(ByteSlice.Prepare("key=" + sKey));
    output.Add(ByteSlice.Prepare("values=" + sValue));
} 
}}}
----



{{{public static string BytesToAscii(IList<byte> x, int offset, int length)}}}

Converts bytes to string using ASCII encoding, starting from offset.  Length is the number of bytes to convert.  A string is allocated each time 

this method is called.  Consider the more efficient method `BytesToAsciiAppend`.

====Example==== 
{{{
byte[] myBuffer = new byte[10];

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    string sKey = UnpadKey(key).ToString();
    string sValue = "";

    for (int i = 0; i < values.Length; i++)
    {
        values[i].Value.CopyTo(myBuffer);
        sValue = Entry.BytesToAscii(myBuffer, 0, 5);

        //Code for manipulating the string...

    }

    output.Add(ByteSlice.Prepare("key=" + sKey));
    output.Add(ByteSlice.Prepare("values=" + sValue));
} 
}}}
----



==`BytesToAsciiAppend`==
{{{public static void BytesToAsciiAppend(IList<byte> x, StringBuilder sb)}}}

Converts bytes to string using ASCII encoding.

====Example==== 
{{{
byte[] myBuffer = new byte[10];
StringBuilder sb = new StringBuilder();

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    string sKey = UnpadKey(key).ToString();
    output.Add(ByteSlice.Prepare("key=" + sKey));

    for (int i = 0; i < values.Length; i++)
    {
        values[i].Value.CopyTo(myBuffer);
        sb.Remove(0, sb.Length);
        Entry.BytesToAsciiAppend(myBuffer, sb);

        //Code for manipulating the string...     


        output.Add(ByteSlice.Prepare(sb));
    }
} 
}}}
----



{{{public static void BytesToAsciiAppend(IList<byte> x, StringBuilder buf, int offset, int length)}}}

Converts bytes to string using ASCII encoding, starting from offset.  Length is the number of bytes to convert.

====Example==== 
{{{
byte[] myBuffer = new byte[10];
StringBuilder sb = new StringBuilder();

public override void Reduce(ByteSlice key, RandomAccessEntries values, RandomAccessOutput output)
{
    string sKey = UnpadKey(key).ToString();
    output.Add(ByteSlice.Prepare("key=" + sKey));

    for (int i = 0; i < values.Length; i++)
    {
        values[i].Value.CopyTo(myBuffer);
        sb.Remove(0, sb.Length);
        Entry.BytesToAsciiAppend(myBuffer, sb, 0, 10);

        //Code for manipulating the string...     


        output.Add(ByteSlice.Prepare(sb));
    }
} 
}}}